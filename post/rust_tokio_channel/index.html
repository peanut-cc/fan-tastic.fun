<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Rust笔记----tokio中的channel - fan-tastic.fun</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="fan-tastic.fun"><meta name=description content="tokio的异步任务之间主要采用消息传递的通信方式，而消息传递使用的是channel,tokio 提供了几种不同功能的channel: oneshot: 一对一"><meta name=keywords content="tokio,channel"><meta name=generator content="Hugo 0.104.0 with theme even"><link rel=canonical href=https://www.fan-tastic.fun/post/rust_tokio_channel/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="Rust笔记----tokio中的channel"><meta property="og:description" content="tokio的异步任务之间主要采用消息传递的通信方式，而消息传递使用的是channel,tokio 提供了几种不同功能的channel: oneshot: 一对一"><meta property="og:type" content="article"><meta property="og:url" content="https://www.fan-tastic.fun/post/rust_tokio_channel/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-08-30T13:41:20+08:00"><meta property="article:modified_time" content="2023-08-31T11:53:45+08:00"><meta itemprop=name content="Rust笔记----tokio中的channel"><meta itemprop=description content="tokio的异步任务之间主要采用消息传递的通信方式，而消息传递使用的是channel,tokio 提供了几种不同功能的channel: oneshot: 一对一"><meta itemprop=datePublished content="2023-08-30T13:41:20+08:00"><meta itemprop=dateModified content="2023-08-31T11:53:45+08:00"><meta itemprop=wordCount content="5963"><meta itemprop=keywords content="tokio,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust笔记----tokio中的channel"><meta name=twitter:description content="tokio的异步任务之间主要采用消息传递的通信方式，而消息传递使用的是channel,tokio 提供了几种不同功能的channel: oneshot: 一对一"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>fan-tastic</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a><a href=/categories/><li class=mobile-menu-item>Categories</li></a><a href=/about/><li class=mobile-menu-item>About</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>fan-tastic</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=/about/>About</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Rust笔记----tokio中的channel</h1><div class=post-meta><span class=post-time>2023-08-30</span><div class=post-category><a href=/categories/rust/>Rust</a></div><span class=more-meta>5963 words</span>
<span class=more-meta>12 mins read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#oneshot>oneshot</a></li><li><a href=#mpsc>mpsc</a><ul><li><a href=#bounded-channel>bounded channel</a></li><li><a href=#unbounded-channel>unbounded channel</a></li></ul></li><li><a href=#broadcast-channel>broadcast channel</a></li><li><a href=#watch-channel>watch channel</a></li></ul></li></ul></nav></div></div><div class=post-content><p>tokio的异步任务之间主要采用消息传递的通信方式，而消息传递使用的是channel,tokio 提供了几种不同功能的channel:</p><ul><li>oneshot: 一对一发送的一次性channel,该channel只能由一个发送者发送最多一个数据,且只有一个接收者接收数据</li><li>mpsc: 多对一发送, 该channel 可以同时由多个发送者发送数据, 但只有一个接收者接收数据</li><li>broadcast: 多对多发送, 该channel可以同时有多个发送者发送数据, 也可以有多个接收者接受数据</li><li>watch: 一对多发送, 该channel只能有一个发送者发送数据, 可以有多个接收者接受数据</li></ul><h2 id=oneshot>oneshot</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>tx</span><span class=p>,</span><span class=w> </span><span class=n>rx</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>oneshot</span>::<span class=n>channel</span>::<span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>tx</span><span class=p>,</span><span class=w> </span><span class=n>rx</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>oneshot</span>::<span class=n>channel</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>tx是发送者(sender)、rx是接收者(receiver)
多数时候不需要去声明通道的类型, 编译器可以根据发送数据时的类型自动推断出类型.</p><p>oneshot channel 只能发送一次数据, <code>send()</code> 发送数据的时候, tx 就直接被消费掉了.
<code>send()</code> 并不一定总能成功发送, 如果发送消息之前 receiver 已经关闭了, 这个时候就会发送失败.
<code>send()</code> 返回的Result, 如果发送成功,则返回<code>Ok(())</code>, 如果失败, 则返回 <code>Err(T)</code>
sender 发送者可以通过<code>is_closed()</code>方法来判断 receiver接收端是否已经关闭。</p><p>sender 发送者可以通过 <code>close()</code> 方法来等待receiver 接收端关闭，结合 <code>select!</code>宏使用</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=n>tokio</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>async</span><span class=w> </span><span class=k>move</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>tokio</span>::<span class=n>select</span><span class=o>!</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tx</span><span class=p>.</span><span class=n>closed</span><span class=p>()</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c1>// 先等待到了对端关闭，不做任何事，select!会自动取消其它分支的任务
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>compute</span><span class=p>()</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=c1>// 先计算得到结果，则发送给对端
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>      </span><span class=c1>// 但有可能刚计算完成，尚未发送时，对端刚好关闭，因此可能发送失败
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>      </span><span class=c1>// 此处丢弃发送失败的错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>      </span><span class=kd>let</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tx</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>});</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>receiver 没有<code>recv()</code> 方法, rx 本身实现了<code>Future Trait</code>, 执行时对应的异步任务就是接收数据,因此只需要await就可以接收数据.</p><p>接收数据也并不一定成功, 如 sender 发送端未发送任何数据就已经关闭了(被drop), 此时receiver 端接收到的就是<code>error::RecvError</code> 错误.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>match</span><span class=w> </span><span class=n>rx</span><span class=p>.</span><span class=k>await</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Ok</span><span class=p>(</span><span class=n>v</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;got = {:?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nb>Err</span><span class=p>(</span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;the sender dropped&#34;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// Err(e: RecvError) =&gt; xxx,
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>关闭receiver端之后，可以保证sender发送端无法再发送消息，但是可能会存在receiver端未完成关闭之前，sender发送端正好发送了一条数据，所以最好是在关闭receiver端之后 调用 <code>try_recv()</code> 方法接收一次数据。</p><p><code>try_recv()</code>方法返回三种可能值：</p><ul><li><code>Ok(T)</code>: 表示成功接收到通道中的数据</li><li><code>Err(TryRecvError::Empty)</code>: 表示通道为空</li><li><code>Err(TryRecvError::Closed)</code>: 表示通道为空，且Sender端已关闭，即Sender未发送任何数据就关闭了</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>tokio</span>::<span class=p>{</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>runtime</span>::<span class=n>Runtime</span><span class=p>,</span><span class=w> </span><span class=n>sync</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>rt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Runtime</span>::<span class=n>new</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>rt</span><span class=p>.</span><span class=n>block_on</span><span class=p>(</span><span class=k>async</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>tx</span><span class=p>,</span><span class=w> </span><span class=n>rx</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sync</span>::<span class=n>oneshot</span>::<span class=n>channel</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>tokio</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>async</span><span class=w> </span><span class=k>move</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=n>tx</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=mi>33</span><span class=p>).</span><span class=n>is_err</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;receiver dropped&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=n>rx</span><span class=p>.</span><span class=k>await</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Ok</span><span class=p>(</span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;received: {:?}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Err</span><span class=p>(</span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;sender dropped&#34;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>另一个比较常见的使用场景是结合<code>select!</code>宏，此时应在recv前面加上<code>&mut</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>interval</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tokio</span>::<span class=n>interval</span><span class=p>(</span><span class=n>tokio</span>::<span class=n>time</span>::<span class=n>Duration</span>::<span class=n>from_millis</span><span class=p>(</span><span class=mi>100</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 注意mut
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>tx</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>rx</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>oneshot</span>::<span class=n>channel</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 注意，select!中无需await，因为select!会自动轮询推进每一个分支的任务进度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>tokio</span>::<span class=n>select</span><span class=o>!</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>interval</span><span class=p>.</span><span class=n>tick</span><span class=p>()</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Another 100ms&#34;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>msg</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>recv</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Got message: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>msg</span><span class=p>.</span><span class=n>unwrap</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=mpsc>mpsc</h2><p>mpsc channel 的特性是可以有多个发送者发送多个消息，且只有一个接收者。mpsc channel 是使用最频繁的通道类型。</p><p>mpsc通道分为两种：</p><ul><li>bounded channel: 有界通道，通道有容量限制，即通道中最多可以存放指定数量(至少为1)的消息，通过<code>mpsc::channel()</code>创建</li><li>unbounded channel: 无界通道，通道中可以无限存放消息，直到内存耗尽，通过<code>mpsc::unbounded_channel()</code>创建</li></ul><h3 id=bounded-channel>bounded channel</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// tx是Sender端，rx是Receiver端
</span></span></span><span class=line><span class=cl><span class=c1>// 接收端接收数据时需修改状态，因此声明为mut
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>tx</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>rx</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mpsc</span>::<span class=n>channel</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>mpsc通道只能有一个Receiver端, 但是可以<code>tx.clone()</code> 得到多个sender 发送端。clone 得到的sender都可以用send() 方法向该通道发送消息。
发送消息时，如果通道已满，发送消息的任务将等待直到通道中有空闲的位置
发送消息时，如果Receiver端已经关闭，则发送消息的操作将返回SendError
如果所有的Sender端都已经关闭，则Receiver端接收消息的方法recv()将返回None</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>tokio</span>::<span class=p>{</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>runtime</span>::<span class=n>Runtime</span><span class=p>,</span><span class=w> </span><span class=n>sync</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>rt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Runtime</span>::<span class=n>new</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>rt</span><span class=p>.</span><span class=n>block_on</span><span class=p>(</span><span class=k>async</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>tx</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>rx</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sync</span>::<span class=n>mpsc</span>::<span class=n>channel</span>::<span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>tokio</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>async</span><span class=w> </span><span class=k>move</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>1</span><span class=o>..=</span><span class=mi>10</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// if let Err(_) = tx.send(i).await {}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=n>tx</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=n>i</span><span class=p>).</span><span class=k>await</span><span class=p>.</span><span class=n>is_err</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;receiver closed&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rx</span><span class=p>.</span><span class=n>recv</span><span class=p>().</span><span class=k>await</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;received: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>上面的例子是生成了一个异步任务，该异步任务向通道发送10个数据，receiver 接收端则在while 循环不断从通道中接收数据。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>tokio</span>::<span class=p>{</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>runtime</span>::<span class=n>Runtime</span><span class=p>,</span><span class=w> </span><span class=n>sync</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>rt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Runtime</span>::<span class=n>new</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>rt</span><span class=p>.</span><span class=n>block_on</span><span class=p>(</span><span class=k>async</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>tx</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>rx</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sync</span>::<span class=n>mpsc</span>::<span class=n>channel</span>::<span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>1</span><span class=o>..=</span><span class=mi>10</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>tx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tx</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>tokio</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>async</span><span class=w> </span><span class=k>move</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=n>tx</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=n>i</span><span class=p>).</span><span class=k>await</span><span class=p>.</span><span class=n>is_err</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;receiver closed&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>drop</span><span class=p>(</span><span class=n>tx</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rx</span><span class=p>.</span><span class=n>recv</span><span class=p>().</span><span class=k>await</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;received: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这个例子中，10个异步任务发送消息的顺序是未知的，因此接收端收到的消息是无法保证顺序的。
这里需要知道，生成的10个一步任务中都有clone后的sender，clone 出的sender 在每个异步任务完成时自动被drop,但原始任务中还有一个sender，如果不关闭这个sender，<code>rx.recv()</code>将不会返回None, 而是一直等待。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>chrono</span>::<span class=n>Local</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>tokio</span>::<span class=n>time</span>::<span class=p>{</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>Duration</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>tokio</span>::<span class=p>{</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>runtime</span>::<span class=n>Runtime</span><span class=p>,</span><span class=w> </span><span class=n>sync</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>now</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nb>String</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Local</span>::<span class=n>now</span><span class=p>().</span><span class=n>format</span><span class=p>(</span><span class=s>&#34;%F %T&#34;</span><span class=p>).</span><span class=n>to_string</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>rt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Runtime</span>::<span class=n>new</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>rt</span><span class=p>.</span><span class=n>block_on</span><span class=p>(</span><span class=k>async</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>tx</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>rx</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sync</span>::<span class=n>mpsc</span>::<span class=n>channel</span>::<span class=o>&lt;</span><span class=kt>i32</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>tokio</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>async</span><span class=w> </span><span class=k>move</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>1</span><span class=o>..=</span><span class=mi>7</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=n>tx</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=n>i</span><span class=p>).</span><span class=k>await</span><span class=p>.</span><span class=n>is_err</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;receiver closed&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>return</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;sended: {}, {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>now</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>time</span>::<span class=n>sleep</span><span class=p>(</span><span class=n>Duration</span>::<span class=n>from_secs</span><span class=p>(</span><span class=mi>1</span><span class=p>)).</span><span class=k>await</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>rx</span><span class=p>.</span><span class=n>recv</span><span class=p>().</span><span class=k>await</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;received: {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>运行结果为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>sended: 1, 2023-08-31 11:19:22
</span></span><span class=line><span class=cl>sended: 2, 2023-08-31 11:19:22
</span></span><span class=line><span class=cl>sended: 3, 2023-08-31 11:19:22
</span></span><span class=line><span class=cl>sended: 4, 2023-08-31 11:19:22
</span></span><span class=line><span class=cl>sended: 5, 2023-08-31 11:19:22
</span></span><span class=line><span class=cl>received: <span class=m>1</span>
</span></span><span class=line><span class=cl>received: <span class=m>2</span>
</span></span><span class=line><span class=cl>received: <span class=m>3</span>
</span></span><span class=line><span class=cl>received: <span class=m>4</span>
</span></span><span class=line><span class=cl>received: <span class=m>5</span>
</span></span><span class=line><span class=cl>received: <span class=m>6</span>
</span></span><span class=line><span class=cl>sended: 6, 2023-08-31 11:19:23
</span></span><span class=line><span class=cl>received: <span class=m>7</span>
</span></span><span class=line><span class=cl>sended: 7, 2023-08-31 11:19:23
</span></span></code></pre></td></tr></table></div></div><p>如果通道已满, Sender通过<code>send()</code>发送消息时将等待.
sender发送端和receiver端有一些常用的方法：</p><p>sender 发送端：</p><ul><li>capacity(): 获取当前通道的剩余容量(注意，不是初始化容量)</li><li>closed(): 等待Receiver端关闭，当Receiver端关闭后该等待任务会立即完成</li><li>is_closed(): 判断Receiver端是否已经关闭</li><li>send(): 向通道中发送消息，通道已满时会等待通道中的空闲位置，如果对端已关闭，则返回错误</li><li>send_timeout(): 向通道中发送消息，通道已满时只等待指定的时长</li><li>try_send(): 向通道中发送消息，但不等待，如果发送不成功，则返回错误</li><li>reserve(): 等待并申请一个通道中的空闲位置，返回一个Permit，申请的空闲位置被占位，且该位置只留给该Permit实例，之后该Permit可以直接向通道中发送消息，并释放其占位的位置。申请成功时，通道空闲容量减1，释放位置时，通道容量会加1</li><li>try_reserve(): 尝试申请一个空闲位置且不等待，如果无法申请，则返回错误</li><li>reserve_owned(): 与reserve()类似，它返回OwnedPermit，但会Move Sender</li><li>try_reserve_owned(): reserve_owned()的不等待版本，尝试申请空闲位置失败时会立即返回错误</li><li>blocking_send(): Sender可以在同步代码环境中使用该方法向异步环境发送消息</li></ul><p>receiver 接收端：</p><ul><li>close(): 关闭Receiver端</li><li>recv(): 接收消息，如果通道已空，则等待，如果对端已全部关闭，则返回None</li><li>try_recv(): 尝试接收消息，不等待，如果无法接收消息(即通道为空或对端已关闭)，则返回错误</li><li>blocking_recv(): Receiver可以在同步代码环境中使用该方法接收来自异步环境的消息</li></ul><p>Receiver的try_recv()方法在无法立即接收消息时会立即返回错误。返回的错误分为两种:</p><ul><li><code>TryRecvError::Empty</code>错误: 表示通道已空，但Sender端尚未全部关闭</li><li><code>TryRecvError::Disconnected</code>错误: 表示通道已空，且Sender端(包括Permit和OwnedPermit)已经全部关闭</li></ul><p>关于<code>reserve()</code>和<code>reserve_owned()</code>，看官方示例进行理解：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>tokio</span>::<span class=n>sync</span>::<span class=n>mpsc</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[tokio::main]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>async</span><span class=w> </span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 创建容量为1的通道
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>tx</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>rx</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mpsc</span>::<span class=n>channel</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 申请并占有唯一的空闲位置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>permit</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tx</span><span class=p>.</span><span class=n>reserve</span><span class=p>().</span><span class=k>await</span><span class=p>.</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 唯一的位置已被permit占有，tx.send()无法发送消息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert!</span><span class=p>(</span><span class=n>tx</span><span class=p>.</span><span class=n>try_send</span><span class=p>(</span><span class=mi>123</span><span class=p>).</span><span class=n>is_err</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Permit可以通过send()方法向它占有的那个位置发送消息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>permit</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=mi>456</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Receiver端接收到消息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>rx</span><span class=p>.</span><span class=n>recv</span><span class=p>().</span><span class=k>await</span><span class=p>.</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=mi>456</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 创建容量为1的通道
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>tx</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>rx</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mpsc</span>::<span class=n>channel</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// tx.reserve_owned()会消费掉tx
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>permit</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tx</span><span class=p>.</span><span class=n>reserve_owned</span><span class=p>().</span><span class=k>await</span><span class=p>.</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 通过permit.send()发送消息，它又返回一个Sender
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>tx</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>permit</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=mi>456</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>rx</span><span class=p>.</span><span class=n>recv</span><span class=p>().</span><span class=k>await</span><span class=p>.</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=mi>456</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//可以继续使用返回的Sender发送消息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>tx</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=mi>789</span><span class=p>).</span><span class=k>await</span><span class=p>.</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=unbounded-channel>unbounded channel</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>tx</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>rx</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>mpsc</span>::<span class=n>unbounded_channel</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>对于无界通道，它的通道中可以缓冲无限数量的消息，直到内存耗尽。</p><h2 id=broadcast-channel>broadcast channel</h2><p>broadcast channel 是一种广播通道，可以有多个Sender端以及多个Receiver端，可以发送多个数据，且任何一个Sender发送的每一个数据都能被所有的Receiver端看到。
使用<code>mpsc::broadcast()</code>创建广播通道，要求指定一个通道容量作为参数。它返回Sender和Receiver。Sender可以克隆得到多个Sender，可以调用Sender的<code>subscribe()</code>方法来创建新的Receiver。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>tokio</span>::<span class=n>sync</span>::<span class=n>broadcast</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[tokio::main]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>async</span><span class=w> </span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 最多存放16个消息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// tx是Sender，rx1是Receiver
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>tx</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>rx1</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>broadcast</span>::<span class=n>channel</span><span class=p>(</span><span class=mi>16</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Sender的subscribe()方法可生成新的Receiver
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>rx2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tx</span><span class=p>.</span><span class=n>subscribe</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tokio</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>async</span><span class=w> </span><span class=k>move</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>rx1</span><span class=p>.</span><span class=n>recv</span><span class=p>().</span><span class=k>await</span><span class=p>.</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=mi>10</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>rx1</span><span class=p>.</span><span class=n>recv</span><span class=p>().</span><span class=k>await</span><span class=p>.</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=mi>20</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tokio</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>async</span><span class=w> </span><span class=k>move</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>rx2</span><span class=p>.</span><span class=n>recv</span><span class=p>().</span><span class=k>await</span><span class=p>.</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=mi>10</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=n>rx2</span><span class=p>.</span><span class=n>recv</span><span class=p>().</span><span class=k>await</span><span class=p>.</span><span class=n>unwrap</span><span class=p>(),</span><span class=w> </span><span class=mi>20</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tx</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=mi>10</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tx</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=mi>20</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Sender端通过<code>send()</code>发送消息的时候，如果所有的Receiver端都已关闭，则<code>send()</code>方法返回错误。</p><p>Receiver端可通过<code>recv()</code>去接收消息，如果所有的Sender端都已经关闭，则该方法返回<code>RecvError::Closed</code>错误。该方法还可能返回<code>RecvError::Lagged</code>错误，该错误表示接收端已经落后于发送端。</p><p>虽然broadcast通道也指定容量，但是通道已满的情况下还可以继续写入新数据而不会等待(因此上面示例中的send()无需await)，此时通道中最旧的(头部的)数据将被剔除，并且新数据添加在尾部。就像是FIFO队列一样。出现这种情况时，就意味着接收端已经落后于发送端。</p><p>当接收端已经开始落后于发送端时，下一次的<code>recv()</code>操作将直接返回<code>RecvError::Lagged</code>错误。如果紧跟着再执行<code>recv()</code>且落后现象未再次发生，那么这次的<code>recv()</code>将取得队列头部的消息。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>tokio</span>::<span class=n>sync</span>::<span class=n>broadcast</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[tokio::main]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>async</span><span class=w> </span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 通道容量2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>tx</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>rx</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>broadcast</span>::<span class=n>channel</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 写入3个数据，将出现接收端落后于发送端的情况，
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// 此时，第一个数据(10)将被剔除，剔除后，20将位于队列的头部
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>tx</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=mi>10</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tx</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=mi>20</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tx</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=mi>30</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 落后于发送端之后的第一次recv()操作，返回RecvError::Lagged错误
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert!</span><span class=p>(</span><span class=n>rx</span><span class=p>.</span><span class=n>recv</span><span class=p>().</span><span class=k>await</span><span class=p>.</span><span class=n>is_err</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 之后可正常获取通道中的数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=mi>20</span><span class=p>,</span><span class=w> </span><span class=n>rx</span><span class=p>.</span><span class=n>recv</span><span class=p>().</span><span class=k>await</span><span class=p>.</span><span class=n>unwrap</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert_eq!</span><span class=p>(</span><span class=mi>30</span><span class=p>,</span><span class=w> </span><span class=n>rx</span><span class=p>.</span><span class=n>recv</span><span class=p>().</span><span class=k>await</span><span class=p>.</span><span class=n>unwrap</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Receiver也可以使用<code>try_recv()</code>方法去无等待地接收消息，如果Sender都已关闭，则返回<code>TryRecvError::Closed</code>错误，如果接收端已落后，则返回<code>TryRecvError::Lagged</code>错误，如果通道为空，则返回<code>TryRecvError::Empty</code>错误。</p><p>另外，<code>tokio::broadcast</code>的任何一个Receiver都可以看到每一次发送的消息，且它们都可以去<code>recv()</code>同一个消息，<code>tokio::broadcast</code>对此的处理方式是消息克隆：每一个Receiver调用<code>recv()</code>去接收一个消息的时候，都会克隆通道中的该消息一次，直到所有存活的Receiver都克隆了该消息，该消息才会从通道中被移除，进而释放一个通道空闲位置。</p><p>这可能会导致一种现象：某个ReceiverA已经接收了通道中的第10个消息，但另一个ReceiverB可能尚未接收第一个消息，由于第一个消息还未被全部接收者所克隆，它仍会保留在通道中并占用通道的位置，假如该通道的最大容量为10，此时Sender再发送一个消息，那么第一个数据将被踢掉，ReceiverB接收到消息的时候将收到<code>RecvError::Lagged</code>错误并永远地错过第一个消息。</p><h2 id=watch-channel>watch channel</h2><p>watch channel 的特性是：只能有单个Sender，可以有多个Receiver，且通道永远只保存一个数据。Sender每次向通道中发送数据时，都会修改通道中的那个数据。</p><p>通道中的这个数据可以被Receiver进行引用读取。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>tokio</span>::<span class=n>sync</span>::<span class=n>watch</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[tokio::main]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>async</span><span class=w> </span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 创建watch通道时，需指定一个初始值存放在通道中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>tx</span><span class=p>,</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>rx</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>watch</span>::<span class=n>channel</span><span class=p>(</span><span class=s>&#34;hello&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Recevier端，通过changed()来等待通道的数据发生变化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// 通过borrow()引用通道中的数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>tokio</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>async</span><span class=w> </span><span class=k>move</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=n>rx</span><span class=p>.</span><span class=n>changed</span><span class=p>().</span><span class=k>await</span><span class=p>.</span><span class=n>is_ok</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;received = {:?}&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=n>rx</span><span class=p>.</span><span class=n>borrow</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 向通道中发送数据，实际上是修改通道中的那个数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tx</span><span class=p>.</span><span class=n>send</span><span class=p>(</span><span class=s>&#34;world&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Sender端可通过<code>subscribe()</code>创建新的Receiver端。</p><p>当所有Receiver端均已关闭时，<code>send()</code>方法将返回错误。也就是说，<code>send()</code>必须要在有Receiver存活的情况下才能发送数据。</p><p>但是Sender端还有一个<code>send_replace()</code>方法，它可以在没有Receiver的情况下将数据写入通道，并且该方法会返回通道中原来保存的值。</p><p>无论是Sender端还是Receiver端，都可以通过<code>borrow()</code>方法取得通道中当前的值。由于可以有多个Receiver，为了避免读写时的数据不一致，watch内部使用了读写锁：Sender端要发送数据修改通道中的数据时，需要申请写锁，论是Sender还是Receiver端，在调用<code>borrow()</code>或其它一些方式访问通道数据时，都需要申请读锁。因此，访问通道数据时要尽快释放读锁，否则可能会长时间阻塞Sender端的发送操作。
如果Sender端未发送数据，或者隔较长时间才发送一次数据，那么通道中的数据在一段时间内将一直保持不变。如果Receiver在这段时间内去多次读取通道，得到的结果将完全相同。但有时候，可能更需要的是等待通道中的数据已经发生变化，然后再根据新的数据做进一步操作，而不是循环不断地去读取并判断当前读取到的值是否和之前读取的旧值相同。</p><p>watch通道已经提供了这种功能：Receiver端可以标记通道中的数据，记录该数据是否已经被读取过。Receiver端的<code>changed()</code>方法用于等待通道中的数据发生变化，其内部判断过程是：如果通道中的数据已经被标记为已读取过，那么<code>changed()</code>将等待数据更新，如果数据未标记过已读取，那么<code>changed()</code>认为当前数据就是新数据，<code>changed()</code>会立即返回。</p><p>Receiver端的<code>borrow()</code>方法不会标记数据已经读取，所以<code>borrow()</code>之后调用的<code>changed()</code>会立即返回。但是<code>changed()</code>等待到新值之后，会立即将该值标记为已读取，使得下次调用changed()时会进行等待。</p><p>此外，Receiver端还有一个<code>borrow_and_update()</code>方法，它会读取数据并标记数据已经被读取，因此随后调用<code>chagned()</code>将进入等待。</p><p>最后再强调一次，无论是Sender端还是Receiver端，访问数据的时候都会申请读锁，要尽量快地释放读锁，以免Sender长时间无法发送数据。</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>fan-tastic.fun</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2023-08-31
<a href=#ZgotmplZ/commit/3aa86951284954bf146433cc2d8ef67933171cff title="feat: 增加tokio channel 笔记">(3aa8695)</a></span></p><p class=copyright-item><span class=item-title>License</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by/4.0/ target=_blank>知识共享署名4.0</a></span></p></div><footer class=post-footer><div class=post-tags><a href=/tags/tokio/>tokio</a></div><nav class=post-nav><a class=next href=/post/rust_tokio_timer/><span class="next-text nav-default">Rust笔记----tokio中的timer</span>
<span class="next-text nav-mobile">Next</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js crossorigin=anonymous></script>
<script type=text/javascript>var gitalk=new Gitalk({id:"2023-08-30 13:41:20 \u002b0800 \u002b0800",title:"Rust笔记----tokio中的channel",clientID:"8e56c7d6ce34f788ca8f",clientSecret:"d8012ab38028c2fffa457e0449f958da07dc84e5",repo:"fan-tastic.fun",owner:"peanut-cc",admin:["peanut-cc"],body:decodeURI(location.href)});gitalk.render("gitalk-container")</script><noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by gitalk.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=https://github.com/peanut-cc class="iconfont icon-github" title=github></a>
<a href=https://www.fan-tastic.fun/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span>
<span class=copyright-year>&copy;
2022 -
2023<span class=heart><i class="iconfont icon-heart"></i></span><span>by fan-tastic.fun</span>
<span><a class=theme-link href=https://beian.miit.gov.cn/>豫ICP备2022023372号-1</a></span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script></body></html>